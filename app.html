<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Gesture Space</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlays */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }
        
        #webcam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border-radius: 10px; border: 2px solid rgba(255,255,255,0.3); transform: scaleX(-1); opacity: 0.7;
        }
        
        .hud-text { color: rgba(255, 255, 255, 0.9); text-shadow: 0 0 10px rgba(0, 150, 255, 0.8); }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; font-size: 1.5rem; }
        
        #status { font-size: 0.9rem; margin-top: 5px; color: #00ffcc; }
        
        .instructions {
            background: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 8px; border-left: 4px solid #d63384;
            max-width: 300px; font-size: 0.85rem; line-height: 1.4; pointer-events: auto;
        }
        .instructions strong { color: #fff; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2rem; background: rgba(0,0,0,0.8); padding: 20px;
            border-radius: 10px; z-index: 20; text-align: center;
        }

        /* Hide video element used for processing */
        #input-video { display: none; }
    </style>
</head>
<body>

    <div id="loading">Initialize Neural Network...<br><small>Please allow camera access</small></div>

    <div id="canvas-container"></div>

    <video id="input-video"></video>

    <div id="ui-layer">
        <div>
            <h1 class="hud-text">COSMIC HANDS</h1>
            <div id="status" class="hud-text">Waiting for hand...</div>
        </div>

        <div class="instructions hud-text">
            <strong>Controls:</strong><br>
            üñê <b>Palm:</b> Hover/Select<br>
            üëå <b>Pinch:</b> Grab & Move<br>
            ‚úä <b>Fist:</b> Explode Block<br>
            üëã <b>Wave:</b> Pan Camera<br>
            üëç <b>Thumbs Up:</b> Duplicate<br>
            üí´ <b>Rotate Wrist:</b> Spin Block
        </div>
        
        <canvas id="webcam-preview"></canvas>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js",
                "@mediapipe/drawing_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { Hands } from '@mediapipe/hands';
        
        // --- Configuration ---
        const BLOCK_COUNT = 12;
        const COLORS = [0x00ffff, 0xff00ff, 0x9933ff, 0x0066ff];
        
        // --- State ---
        const state = {
            handDetected: false,
            gesture: 'None',
            cursor: new THREE.Vector2(), // Screen coordinates (-1 to 1)
            handDepth: 0,
            pinchedObject: null,
            hoveredObject: null,
            lastWaveX: 0,
            waveCooldown: 0,
            duplicateCooldown: 0
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.02);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 50);
        pointLight.position.set(0, 5, 5);
        scene.add(pointLight);
        
        // Add subtle colored lights for atmosphere
        const p1 = new THREE.PointLight(0xff00ff, 1, 20); p1.position.set(-10, 5, 0); scene.add(p1);
        const p2 = new THREE.PointLight(0x00ffff, 1, 20); p2.position.set(10, -5, 0); scene.add(p2);

        // --- Objects: Stars ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random() - 0.5) * 50;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.05, transparent: true, opacity: 0.8});
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- Objects: Blocks ---
        const blocks = [];
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        // Iridescent Glass Material
        const baseMaterial = new THREE.MeshPhysicalMaterial({
            transmission: 0.6,
            thickness: 1.5,
            roughness: 0.1,
            ior: 1.5,
            color: 0xffffff,
            emissive: 0x000000,
            metalness: 0.1,
            clearcoat: 1
        });

        function createBlock(pos) {
            const material = baseMaterial.clone();
            material.color.setHex(COLORS[Math.floor(Math.random() * COLORS.length)]);
            material.emissive.setHex(material.color.getHex());
            material.emissiveIntensity = 0.2;

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos || new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 6,
                (Math.random() - 0.5) * 4
            ));
            
            // Random initial rotation
            mesh.rotation.set(Math.random(), Math.random(), Math.random());
            
            // Custom physics data
            mesh.userData = {
                velocity: new THREE.Vector3(),
                rotationSpeed: new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01, 0),
                floatOffset: Math.random() * 100,
                originalScale: 1
            };
            
            scene.add(mesh);
            blocks.push(mesh);
            return mesh;
        }

        for(let i=0; i<BLOCK_COUNT; i++) createBlock();

        // --- Cursor ---
        const cursorGeo = new THREE.SphereGeometry(0.1, 16, 16);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
        const cursor3D = new THREE.Mesh(cursorGeo, cursorMat);
        scene.add(cursor3D);

        // --- Particles (Explosion) ---
        const particles = [];
        function explodeBlock(block) {
            scene.remove(block);
            const index = blocks.indexOf(block);
            if (index > -1) blocks.splice(index, 1);
            
            // Create shards
            const shardGeo = new THREE.TetrahedronGeometry(0.2, 0);
            for(let i=0; i<15; i++) {
                const shard = new THREE.Mesh(shardGeo, block.material.clone());
                shard.position.copy(block.position);
                shard.material.transparent = true;
                shard.userData = {
                    velocity: new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3),
                    life: 1.0
                };
                scene.add(shard);
                particles.push(shard);
            }
        }

        // --- MediaPipe Setup ---
        const videoElement = document.getElementById('input-video');
        const previewCanvas = document.getElementById('webcam-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const statusElement = document.getElementById('status');
        const loadingElement = document.getElementById('loading');

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // --- Webcam Init ---
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                videoElement.srcObject = stream;
                videoElement.play();
                
                // Initialize MediaPipe processing loop
                const cameraLoop = async () => {
                    await hands.send({image: videoElement});
                    requestAnimationFrame(cameraLoop);
                };
                videoElement.onloadeddata = () => {
                    loadingElement.style.display = 'none';
                    cameraLoop();
                };
            } catch (err) {
                loadingElement.innerHTML = "Camera access denied.<br>Please enable camera to play.";
                console.error(err);
            }
        }
        startCamera();

        // --- Gesture Recognition Logic ---
        function onResults(results) {
            // Draw preview
            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw skeleton on preview
                drawSkeleton(previewCtx, landmarks);

                // 1. Map Hand Position to Screen Cursor
                // Index finger tip (8) and Thumb tip (4) midpoint for cursor
                const x = (landmarks[8].x + landmarks[4].x) / 2;
                const y = (landmarks[8].y + landmarks[4].y) / 2;
                
                // Convert to Normalized Device Coordinates (-1 to +1)
                // Note: MediaPipe x is 0(left) to 1(right). ThreeJS is -1(left) to 1(right).
                // But Webcam is mirrored usually. Let's handle logical mapping:
                // If I move hand right in air, I want cursor to go right.
                // MediaPipe output is already mirrored relative to user if using selfie mode logic usually.
                // Let's invert X to feel natural.
                state.cursor.x = (1 - x) * 2 - 1; 
                state.cursor.y = -(y * 2 - 1); // Invert Y
                
                // 2. Gesture Detection
                detectGestures(landmarks);
                
                statusElement.innerText = `Detected: ${state.gesture}`;
                statusElement.style.color = state.gesture === 'None' ? '#fff' : '#00ffcc';

            } else {
                state.handDetected = false;
                statusElement.innerText = "Waiting for hand...";
                state.gesture = 'None';
                state.pinchedObject = null;
            }
            previewCtx.restore();
        }

        function drawSkeleton(ctx, landmarks) {
            ctx.strokeStyle = '#00ffcc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Simple connections for preview
            const connections = [[0,1],[1,2],[2,3],[3,4], [0,5],[5,6],[6,7],[7,8], [5,9],[9,10],[10,11],[11,12], [9,13],[13,14],[14,15],[15,16], [13,17],[17,18],[18,19],[19,20], [0,17]];
            
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;

            connections.forEach(pair => {
                const p1 = landmarks[pair[0]];
                const p2 = landmarks[pair[1]];
                ctx.moveTo(p1.x * w, p1.y * h);
                ctx.lineTo(p2.x * w, p2.y * h);
            });
            ctx.stroke();
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
        }

        function detectGestures(lm) {
            const thumbTip = lm[4];
            const indexTip = lm[8];
            const middleTip = lm[12];
            const ringTip = lm[16];
            const pinkyTip = lm[20];
            const wrist = lm[0];

            // 1. Pinch (Thumb + Index close)
            const pinchDist = distance(thumbTip, indexTip);
            const isPinching = pinchDist < 0.05;

            // 2. Fist (All fingers close to wrist)
            const fingersOpen = (distance(indexTip, wrist) > 0.3 && distance(middleTip, wrist) > 0.3);
            const isFist = !fingersOpen && !isPinching;

            // 3. Thumbs Up (Thumb up, others curled)
            // Thumb tip y is significantly higher (lower value) than thumb IP, and other fingers curled
            const isThumbsUp = (thumbTip.y < lm[3].y) && !fingersOpen && pinchDist > 0.1;

            // 4. Wave (Track wrist movement)
            // Simple logic: if x changes rapidly
            const currX = wrist.x;
            if (state.waveCooldown <= 0 && Math.abs(currX - state.lastWaveX) > 0.15 && fingersOpen) {
                state.gesture = 'Wave';
                state.waveCooldown = 20;
            }
            state.lastWaveX = currX;
            if(state.waveCooldown > 0) state.waveCooldown--;

            // 5. Rotation (Angle of Index Metacarpal vs vertical)
            // Check tilt of hand
            const dx = lm[9].x - lm[0].x;
            const dy = lm[9].y - lm[0].y;
            const angle = Math.atan2(dy, dx); // Radians
            
            // --- Set State ---
            if (state.gesture === 'Wave' && state.waveCooldown > 0) {
                // Keep wave active
            } else if (isFist) {
                state.gesture = 'Fist';
            } else if (isThumbsUp) {
                state.gesture = 'ThumbsUp';
            } else if (isPinching) {
                state.gesture = 'Pinch';
            } else {
                state.gesture = 'Open Palm';
            }

            state.handRotation = angle;
        }

        // --- Main Animation Loop ---
        const raycaster = new THREE.Raycaster();
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. Update Raycaster based on cursor
            raycaster.setFromCamera(state.cursor, camera);
            
            // Move 3D cursor
            const cursorDist = 6; // distance from camera
            const cursorVec = new THREE.Vector3(state.cursor.x, state.cursor.y, 0.5).unproject(camera);
            const dir = cursorVec.sub(camera.position).normalize();
            const targetCursorPos = camera.position.clone().add(dir.multiplyScalar(cursorDist));
            cursor3D.position.lerp(targetCursorPos, 0.2);

            // 2. Interaction Logic
            
            // Check intersections if not already dragging something
            if (!state.pinchedObject) {
                const intersects = raycaster.intersectObjects(blocks);
                
                // Clear previous hover
                if (state.hoveredObject && (!intersects.length || intersects[0].object !== state.hoveredObject)) {
                    state.hoveredObject.material.emissiveIntensity = 0.2; // Reset glow
                    state.hoveredObject.scale.setScalar(state.hoveredObject.userData.originalScale);
                    state.hoveredObject = null;
                }

                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    state.hoveredObject = obj;
                    
                    // Highlight effect
                    obj.material.emissiveIntensity = 0.8; 
                    const scaleOsc = 1 + Math.sin(time * 10) * 0.05;
                    obj.scale.setScalar(obj.userData.originalScale * scaleOsc);
                    
                    // Interaction Triggers
                    if (state.gesture === 'Pinch') {
                        state.pinchedObject = obj;
                    }
                    if (state.gesture === 'Fist') {
                        explodeBlock(obj);
                        state.hoveredObject = null;
                    }
                }
                
                // Global Actions
                if (state.gesture === 'Wave' && state.waveCooldown > 15) {
                     // Pan Camera logic
                     const panSpeed = (state.cursor.x > 0 ? 1 : -1) * 0.1;
                     camera.position.x += panSpeed;
                     camera.lookAt(0,0,0);
                }
                
                if (state.gesture === 'ThumbsUp') {
                    if (state.duplicateCooldown <= 0 && state.hoveredObject) {
                        createBlock(state.hoveredObject.position.clone().add(new THREE.Vector3(1.2,0,0)));
                        state.duplicateCooldown = 60; // 1 second cooldown
                    }
                }
            } else {
                // Dragging Logic
                const obj = state.pinchedObject;
                
                if (state.gesture !== 'Pinch') {
                    // Release
                    state.pinchedObject = null;
                } else {
                    // Move object to cursor
                    obj.position.lerp(cursor3D.position, 0.1);
                    obj.rotation.x += 0.02;
                    obj.rotation.y += 0.02;
                    
                    // Rotate Wrist Logic
                    // Normal angle is roughly -1.5 (vertical). 
                    // If user twists wrist, angle changes.
                    // Simple implementation: rotate object based on hand tilt
                    obj.rotation.z = state.handRotation + 1.5; 
                }
            }
            
            if(state.duplicateCooldown > 0) state.duplicateCooldown--;

            // 3. Update Scene Physics/Animations
            blocks.forEach((block, i) => {
                if (block !== state.pinchedObject) {
                    // Idle Float
                    block.position.y += Math.sin(time + block.userData.floatOffset) * 0.002;
                    block.rotation.x += 0.001;
                    block.rotation.y += 0.001;
                }
            });

            // Update Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.rotation.x += 0.1;
                p.material.opacity -= 0.02;
                p.userData.life -= 0.02;
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            // Move stars slowly
            stars.rotation.y += 0.0005;

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
